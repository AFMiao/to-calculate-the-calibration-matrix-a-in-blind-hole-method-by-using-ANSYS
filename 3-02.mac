! 工作目录
! D:/LEARNING/Courses/IV/FECD/manual/code
FINISH $ /CLEAR
/FILNAME,3-02
/TITLE,3-02
!==========
! 长度单位统一为mm
! 注: 用等式给参数赋值的时候
! 运算符号前后千万不要加空格
D = 5.13 $ D0 = 0.5*D
DEPTH = 1.2*D $ L = 10*D
ENUM_L=10 $ ENUM_ARC=5

R1 = 1.77 $ R2 = 3.36
GL = 1.59 $ GW = 1.59
L1 = (D0/2+R1)/2

dh = 0.05 $ n = 20
h = dh*n $ DA = DH*L
SIGMA = 100

E = 2.1E5 $ v = 0.3
!==========
/PREP7
ET,1,SOLID186
! KEYOPT,1,2,3

ET,2,PLANE183

MP,EX,1,E
MP,PRXY,1,v
!==========
! 建立工件下表面
*DIM,P_PQRS,ARRAY,4
*DO,I,1,4,1
  P_PQRS(I)=I
*ENDDO
K,1,  L,  L,0  ! P
K,2,  0,  L,0  ! Q
K,3,  0,  0,0  ! R
K,4,  L,  0,0  ! S
K,5,L/2,L/2,0  ! 圆心

*DIM,L_PQRS,ARRAY,4
L,1,2 $ L_PQRS(1)=_RETURN  ! PQ
L,2,3 $ L_PQRS(2)=_RETURN  ! QR
L,3,4 $ L_PQRS(3)=_RETURN  ! RS
L,4,1 $ L_PQRS(4)=_RETURN  ! SP

*DIM,P_PQRS0,ARRAY,4
*DO,I,1,4,1
  P_PQRS0(I)=1000+I
*ENDDO
K,1001,L/2+L1,L/2+L1,0  ! P1
K,1002,L/2-L1,L/2+L1,0  ! Q1
K,1003,L/2-L1,L/2-L1,0  ! R1
K,1004,L/2+L1,L/2-L1,0  ! S1

*DIM,L_PQRS0,ARRAY,4
L,1001,1002 $ L_PQRS0(1)=_RETURN  ! P1Q1
L,1002,1003 $ L_PQRS0(2)=_RETURN  ! Q1R1
L,1003,1004 $ L_PQRS0(3)=_RETURN  ! R1S1
L,1004,1001 $ L_PQRS0(4)=_RETURN  ! S1P1

*DIM,P_PQRS01,ARRAY,4
*DO,I,1,4,1
  P_PQRS01(I)=1100+I
*ENDDO
K,1101,L/2+2*R2,L/2+2*R2,0  ! P11
K,1102,L/2-2*R2,L/2+2*R2,0  ! Q11
K,1103,L/2-2*R2,L/2-2*R2,0  ! R11
K,1104,L/2+2*R2,L/2-2*R2,0  ! S11

*DIM,L_PQRS01,ARRAY,4
L,1101,1102 $ L_PQRS01(1)=_RETURN  ! P11Q11
L,1102,1103 $ L_PQRS01(2)=_RETURN  ! Q11R11
L,1103,1104 $ L_PQRS01(3)=_RETURN  ! R11S11
L,1104,1101 $ L_PQRS01(4)=_RETURN  ! S11P11

! 建立圆
CIRCLE,5,D0/2
ARC_AISSIT1=_RETURN
*DIM,MIDPOINT,ARRAY,4  ! 创建一个储存中点序号的数组
*DO,I,1,4,1
  MIDPOINT(I)=60+I
*ENDDO
*DO,I,0,3,1  ! 创建中点、赋值并分割
  KL,ARC_AISSIT1+I,0.5,MIDPOINT(I+1)
  L,MIDPOINT(I+1),P_PQRS(I+1)
  L_CACHE=_RETURN
  LSBL,ARC_AISSIT1+I,L_CACHE
*ENDDO

! 将分割开的圆弧连接起来
*DIM,ARC,ARRAY,4
LCOMB,17,19,0 $ ARC(1)=_RETURN
LCOMB,14,20,0 $ ARC(2)=_RETURN
LCOMB,21,22,0 $ ARC(3)=_RETURN
LCOMB,15,18,0 $ ARC(4)=_RETURN

! 连接对角线
*DIM,DIAGONAL,ARRAY,4
*DO,I,1,4,1
  L,P_PQRS(I),P_PQRS01(I)
  DIAGONAL(I)=_RETURN
*ENDDO

*DIM,DIAGONAL0,ARRAY,4
*DO,I,1,4,1
  L,P_PQRS0(I),MIDPOINT(I)
  DIAGONAL0(I)=_RETURN
*ENDDO

*DIM,DIAGONAL01,ARRAY,4
*DO,I,1,4,1
  L,P_PQRS01(I),P_PQRS0(I)
  DIAGONAL01(I)=_RETURN
*ENDDO

! 创建应变片1
*DIM,P_GAUGE1,ARRAY,4
*DO,I,1,4,1
  P_GAUGE1(I)=10+I
*ENDDO
K,11,L/2+R2,L/2+GW/2
K,12,L/2+R1,L/2+GW/2
K,13,L/2+R1,L/2-GW/2
K,14,L/2+R2,L/2-GW/2

*DIM,L_GAUGE1,ARRAY,4
L,11,12 $ L_GAUGE1(1)=_RETURN
L,12,13 $ L_GAUGE1(2)=_RETURN
L,13,14 $ L_GAUGE1(3)=_RETURN
L,14,11 $ L_GAUGE1(4)=_RETURN

*DIM,DIAGONAL1,ARRAY,4
L,P_GAUGE1(1),P_PQRS01(1)  $ DIAGONAL1(1)=_RETURN
L,P_GAUGE1(2),P_PQRS0(1)   $ DIAGONAL1(2)=_RETURN
L,P_GAUGE1(3),P_PQRS0(4)   $ DIAGONAL1(3)=_RETURN
L,P_GAUGE1(4),P_PQRS01(4)  $ DIAGONAL1(4)=_RETURN

! 创建应变片3
*DIM,P_GAUGE3,ARRAY,4
*DO,I,1,4,1
  P_GAUGE3(I)=30+I
*ENDDO
K,31,L/2+GW/2,L/2-R1
K,32,L/2-GW/2,L/2-R1
K,33,L/2-GW/2,L/2-R2
K,34,L/2+GW/2,L/2-R2

*DIM,L_GAUGE3,ARRAY,4
L,31,32 $ L_GAUGE3(1)=_RETURN
L,32,33 $ L_GAUGE3(2)=_RETURN
L,33,34 $ L_GAUGE3(3)=_RETURN
L,34,31 $ L_GAUGE3(4)=_RETURN

*DIM,DIAGONAL3,ARRAY,4
L,P_GAUGE3(1), P_PQRS0(4) $ DIAGONAL3(1)=_RETURN
L,P_GAUGE3(2), P_PQRS0(3) $ DIAGONAL3(2)=_RETURN
L,P_GAUGE3(3),P_PQRS01(3) $ DIAGONAL3(3)=_RETURN
L,P_GAUGE3(4),P_PQRS01(4) $ DIAGONAL3(4)=_RETURN

!! 创建面
AL,DIAGONAL(1),L_PQRS(1),DIAGONAL(2),L_PQRS01(1)
AL,DIAGONAL(2),L_PQRS(2),DIAGONAL(3),L_PQRS01(2)
AL,DIAGONAL(3),L_PQRS(3),DIAGONAL(4),L_PQRS01(3)
AL,DIAGONAL(4),L_PQRS(4),DIAGONAL(1),L_PQRS01(4)

AL,DIAGONAL01(1),L_PQRS01(1),DIAGONAL01(2),L_PQRS0(1)
AL,DIAGONAL01(2),L_PQRS01(2),DIAGONAL01(3),L_PQRS0(2)

AL,DIAGONAL0(1),L_PQRS0(1),DIAGONAL0(2),ARC(1)
AL,DIAGONAL0(2),L_PQRS0(2),DIAGONAL0(3),ARC(2)
AL,DIAGONAL0(3),L_PQRS0(3),DIAGONAL0(4),ARC(3)
AL,DIAGONAL0(4),L_PQRS0(4),DIAGONAL0(1),ARC(4)

AL,DIAGONAL1(1),DIAGONAL01(1),DIAGONAL1(2),L_GAUGE1(1)
AL,DIAGONAL1(2),   L_PQRS0(4),DIAGONAL1(3),L_GAUGE1(2)
AL,DIAGONAL1(3),DIAGONAL01(4),DIAGONAL1(4),L_GAUGE1(3)
AL,DIAGONAL1(4),  L_PQRS01(4),DIAGONAL1(1),L_GAUGE1(4)

AL,L_GAUGE1(1),L_GAUGE1(2),L_GAUGE1(3),L_GAUGE1(4)

AL,DIAGONAL3(1),   L_PQRS0(3),DIAGONAL3(2),L_GAUGE3(1)
AL,DIAGONAL3(2),DIAGONAL01(3),DIAGONAL3(3),L_GAUGE3(2)
AL,DIAGONAL3(3),  L_PQRS01(3),DIAGONAL3(4),L_GAUGE3(3)
AL,DIAGONAL3(4),DIAGONAL01(4),DIAGONAL3(1),L_GAUGE3(4)

AL,L_GAUGE3(1),L_GAUGE3(2),L_GAUGE3(3),L_GAUGE3(4)

AL,ARC(1),ARC(2),ARC(3),ARC(4)

!! 设置单元大小
*DO,I,1,4,1
  LESIZE,       ARC(I),,,ENUM_ARC
  LESIZE,    L_PQRS(I),,,ENUM_ARC
  LESIZE,   L_PQRS0(I),,,ENUM_ARC
  LESIZE,  L_PQRS01(I),,,ENUM_ARC
  LESIZE, DIAGONAL0(I),,,ENUM_ARC

  LESIZE,  DIAGONAL(I),,,ENUM_L
  LESIZE,DIAGONAL01(I),,,ENUM_L

  LESIZE, DIAGONAL1(I),,,ENUM_ARC
  LESIZE, DIAGONAL3(I),,,ENUM_ARC
*ENDDO

LESIZE,L_GAUGE1(1),,,ENUM_L
LESIZE,L_GAUGE1(2),,,ENUM_ARC
LESIZE,L_GAUGE1(3),,,ENUM_L
LESIZE,L_GAUGE1(4),,,ENUM_ARC

LESIZE,L_GAUGE3(1),,,ENUM_ARC
LESIZE,L_GAUGE3(2),,,ENUM_L
LESIZE,L_GAUGE3(3),,,ENUM_ARC
LESIZE,L_GAUGE3(4),,,ENUM_L

!! 划分网格
ASEL,ALL
MSHAPE,0,2D
MSHKEY,1
AMESH,ALL

! extrude
TYPE=1
MAT=1
K,51,,,DEPTH-h
K,52,,,DEPTH
L,3,51
L_CACHE1=_RETURN
L,51,52
L_CACHE2=_RETURN
LESIZE,L_CACHE1,,,5
LESIZE,L_CACHE2,,,N

ASEL,ALL
VDRAG,ALL,,,,,,L_CACHE1,L_CACHE2


!! 选取单元
! 建立柱坐标系, 命名为11
K,100,L/2,L/2  ! 柱坐标系原点
K,101,L,L/2  ! 柱坐标系x轴方向
K,102,L/2,L  ! 柱坐标系"y"轴方向
CSKP,11,1,100,101,102
CSYS,11  ! 打开坐标系11

! 选取单元
ESEL,S,CENT,X,0,D0/2
ESEL,R,CENT,Z,DEPTH-H,DEPTH

!! 对单元进行排序
! 获取最大单元编号
*GET,EMAX,ELEM,,NUM,MAX
! 获取最小单元编号
*GET,EMIN,ELEM,,NUM,MIN
! 获取单元数
*GET,SUM_ELEM,ELEM,,COUNT
! 定义五个维数等于单元数的数组
*DIM,NE,,SUM_ELEM
*DIM,EX,,SUM_ELEM
*DIM,EY,,SUM_ELEM
*DIM,EZ,,SUM_ELEM
*DIM,EORDER,,SUM_ELEM

! 获取单元的编号以及坐标数据
II = 0  ! 辅助变量
*DO,I,EMIN,EMAX,1
  *IF,ESEL(I),EQ,1,THEN
    II = II+1  ! 如果单元被选中
    NE(II) = I  ! 则将其的序号记录在数组NE内
    ! 将其的坐标记录在数组内
    *GET,EX(II),ELEM,NE(II),CENT,X
    *GET,EY(II),ELEM,NE(II),CENT,Y
    *GET,EZ(II),ELEM,NE(II),CENT,Z
  *ENDIF
*ENDDO

!! 这里打算用matlab写一个排序程序
!! 把他封装为exe后在ANSYS里面调用
!! 不然排序太折磨人了
*CREATE,datawrite,mac  ! 创建写出宏
! 写出NE
*CFOPEN,NE,dat
  *VWRITE,NE(1)
  (960F6.0)
*CFCLOSE
! 写出EX
*CFOPEN,EX,dat
  *VWRITE,EX(1)
  (960F11.9)
*CFCLOSE
! 写出EY
*CFOPEN,EY,dat
  *VWRITE,EY(1)
  (960F12.6)
*CFCLOSE
! 写出EZ
*CFOPEN,EZ,dat
  *VWRITE,EZ(1)
  (960F6.3)
*CFCLOSE
*END  ! 宏创建完毕
Datawrite  ! 运行宏文件

!! 运行MATLAB排序文件
/sys,sorting.exe

!! 读入MATLAB排序结果
*CREATE,DATAREAD,mac
*VREAD,EORDER(1),EORDER,dat,,IJK
(f6.0)
*END
DATAREAD

!! 为数据提取做准备
! 激活整体坐标系
CSYS,0

! 提取第一组应变片对应的单元序号
! 选中第一组应变片对应的单元
ESEL,ALL
ESEL,R,CENT,X,L/2+R1,L/2+R2
ESEL,R,CENT,Y,L/2-GW/2,L/2+GW/2
ESEL,R,CENT,Z,DEPTH-DH,DEPTH+DH
! 获取区域内单元最大序号
*GET,NUM_GAUGE1_MAX,ELEM,0,NUM,MAX
! 获取区域内单元最小序号
*GET,NUM_GAUGE1_MIN,ELEM,0,NUM,MIN
! 获取区域内单元数量
*GET,COUNT_STRAIN_GAUGE1,ELEM,0,COUNT
! 定义一个用于储存单元序号的数组
*DIM,STRAIN_GAUGE1,ARRAY,COUNT_STRAIN_GAUGE1
! 设定一个辅助参数
II=0
! 记录
*DO,I,NUM_GAUGE1_MIN,NUM_GAUGE1_MAX,1
  ! 判断单元是否被选中
  *IF,ESEL(I),EQ,1,THEN
    ! 如果单元被选中
    II=II+1
    ! 则将其记录在数组STRAIN_GAUGE1内
    STRAIN_GAUGE1(II)=I
  *ENDIF
*ENDDO  ! 结束记录

! 提取第三组应变片对应的单元序号
! 选中第三组应变片对应的单元
ESEL,ALL
ESEL,R,CENT,X,L/2-GW/2,L/2+GW/2
ESEL,R,CENT,Y,L/2-R2,L/2-R1
ESEL,R,CENT,Z,DEPTH-DH,DEPTH+DH
! 获取区域内单元最大序号
*GET,NUM_GAUGE3_MAX,ELEM,0,NUM,MAX
! 获取区域内单元最小序号
*GET,NUM_GAUGE3_MIN,ELEM,0,NUM,MIN
! 获取区域内单元数量
*GET,COUNT_STRAIN_GAUGE3,ELEM,0,COUNT
! 定义一个用于储存单元序号的数组
*DIM,STRAIN_GAUGE3,ARRAY,COUNT_STRAIN_GAUGE3
! 设定一个辅助参数
II=0
! 记录
*DO,I,NUM_GAUGE3_MIN,NUM_GAUGE3_MAX,1
  ! 判断单元是否被选中
  *IF,ESEL(I),EQ,1,THEN
    ! 如果单元被选中
    II=II+1
    ! 则将其记录在数组STRAIN_GAUGE2内
    STRAIN_GAUGE3(II)=I
  *ENDIF
*ENDDO  ! 结束记录

! 建立应变矩阵(ANSYS计算不了太复杂的式子)
*DIM,MATRIX_EP1,ARRAY,N,N
*DIM,MATRIX_EP3,ARRAY,N,N
! 建立两个算术用的变量
*SET,SUM_EP,0
*SET,AVG_EP,0


ALLSEL,ALL
FINISH

!!-----求解-----
/SOLU
! 分步求解
*DO,I,1,N,1
  *DO,K,1,I,1
    /VIEW,1,L,L,L $ /ANG,1
    
    /SOLU
    ! 求解设置
    ANTYPE,STATIC  ! 设置分析类型为STATIC
    ! EQSLV,PCG,1.0E-5  ! 设置求解器为预共轭梯度法, 公差为1.0E-5
    AUTOTS,ON  ! 自动时间步
    ! NSUBST,200,1000000,20  ! 设置载荷步
    ! NEQIT,100  ! 设置平衡迭代步数
    NLGEOM,ON  ! 打开大变形效应
    NROPT,FULL  ! 使用不省略的NEWTON-RAPHSON选项
    LNSRCH,ON

    ! DEATH
    *DO,J,1+(I-1)*(SUM_ELEM/N),I*(SUM_ELEM/N),1
      EKILL,EORDER(J)
    *ENDDO

    ! 清除所有约束及载荷
    LSCLEAR,ALL

    !! 施加约束
    *DO,JJ,1,4,1
      DK,JJ,ALL
    *ENDDO
    
    !! 施加载荷
    ! 选取待加载单元
    CSYS,11
    ESEL,ALL
    NSEL,ALL
    NSEL,R,LOC,X,0,D0/2
    ESLN,ALL
    ESEL,U,CENT,X,0,D0/2
    ESEL,R,CENT,Z,DEPTH-K*DH,DEPTH-(K-1)*DH

    SFE,ALL,3,PRES,1,SIGMA

    CSYS,0
  
    ALLSEL,ALL
    EPLOT

    !! 求解
    SOLVE
    FINISH

    !! 提取数据
    /POST1
    ETABLE,EPEL_Y,EPEL,Y
    ETABLE,EPEL_X,EPEL,X

    *SET,DEP,0
    *SET,SUM_EP,0
    *DO,II,1,COUNT_STRAIN_GAUGE1,1
      *GET,DEP,ELEM,STRAIN_GAUGE1(II),ETAB,EPEL_X
      *SET,SUM_EP,SUM_EP+DEP
    *ENDDO
    *SET,EP1,SUM_EP/COUNT_STRAIN_GAUGE1

    *SET,DEP,0
    *SET,SUM_EP,0
    *DO,II,1,COUNT_STRAIN_GAUGE3,1
      *GET,DEP,ELEM,STRAIN_GAUGE3(II),ETAB,EPEL_Y
      *SET,SUM_EP,SUM_EP+DEP
    *ENDDO
    *SET,EP3,SUM_EP/COUNT_STRAIN_GAUGE3
    FINISH

    *SET,MATRIX_EP1(I,K),EP1
    *SET,MATRIX_EP3(I,K),EP3
    FINISH
  *ENDDO
*ENDDO


!! 输出应变矩阵
*CREATE,MATRICES_OUTPUT,mac
*MWRITE,MATRIX_EP1,EP1,dat,,JIK,20,20
(20F25.22)
*MWRITE,MATRIX_EP3,EP3,dat,,JIK,20,20
(20F25.22)
*END
MATRICES_OUTPUT

!! 利用matlab进行计算
/sys,calculate.exe

!! 生死单元法
!-----TEST-----
! 选取单元
! CSYS,11
! ESEL,S,CENT,X,0,D0/2
! ESEL,R,CENT,Z,DEPTH-H,DEPTH
! EPLOT

! DEAD OR ALIVE
! *DO,I,1,SUM_ELEM,1
!   EKILL,EORDER(I)
!   ESEL,R,LIVE
!   EPLOT
! *ENDDO

