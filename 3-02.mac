! 工作目录
! D:/LEARNING/Courses/IV/FECD/manual/code
FINISH $ /CLEAR
/FILNAME,3-02
/TITLE,3-02
!==========
! 长度单位统一为mm
! 注: 用等式给参数赋值的时候
! 运算符号前后千万不要加空格
D = 5.13 $ D0 = 0.5*D
DEPTH = 1.2*D $ L = 10*D
ENUM_L=5

R1 = 1.77 $ R2 = 3.36
GL = 1.59 $ GW = 1.59

dh = 0.05 $ n = 20
h = dh*n $ DA = DH*L
SIGMA_X = 100

E = 2.1E5 $ v = 0.3
!==========
/PREP7
ET,1,SOLID186
! KEYOPT,1,2,3

ET,2,MESH200,7

MP,EX,1,E
MP,PRXY,1,v
MP,EX,2,E
MP,PRXY,2,v
!==========
! 建立工件下表面
K,1,0,0,0  ! P1
K,2,L,0,0  ! Q1
K,3,L,L,0  ! R1
K,4,0,L,0  ! S1

L,1,2 $ P1Q1=_RETURN
L,2,3 $ Q1R1=_RETURN
L,3,4 $ R1S1=_RETURN
L,4,1 $ S1P1=_RETURN

K,41,L/2-2*D0,L/2-2*D0,0  ! P0
K,42,L/2+2*D0,L/2-2*D0,0  ! Q0
K,43,L/2+2*D0,L/2+2*D0,0  ! R0
K,44,L/2-2*D0,L/2+2*D0,0  ! S0

L,41,42 $ P0Q0=_RETURN
L,42,43 $ Q0R0=_RETURN
L,43,44 $ R0S0=_RETURN
L,44,41 $ S0P0=_RETURN
AL,P0Q0,Q0R0,R0S0,S0P0
A0=_RETURN

L,1,41 $ P0P1=_RETURN
L,2,42 $ Q0Q1=_RETURN
L,3,43 $ R0R1=_RETURN
L,4,44 $ S0S1=_RETURN

AL,P1Q1,Q0Q1,P0Q0,P0P1
AL,Q1R1,R0R1,Q0R0,Q0Q1
AL,R0S0,R0R1,R1S1,S0S1
AL,P0P1,S0P0,S0S1,S1P1

! 建立圆面
CYL4,L/2,L/2,D0/2

! 减去不必要的部分
ASEL,A,LOC,X,L/2-D0/2-0.1,L/2+D0/2+0.1
ASBA,A0,ALL,,DELETE,KEEP
! 获取新生成的面的序号
*GET,A0,AREA,0,NUM,MAX

! 通过循环创建应变花
K,11,L/2+R1,L/2+GW/2
K,12,L/2+R1,L/2-GW/2
K,13,L/2+R2,L/2-GW/2
K,14,L/2+R2,L/2+GW/2

! K,21,L/2-0.5*D/1.414         ,L/2+0.5*D/1.414-GW/1.414
! K,22,L/2-0.5*D/1.414+GL/1.414,L/2+0.5*D/1.414
! K,23,L/2-0.5*D/1.414         ,L/2+0.5*D/1.414+GW/1.414
! K,24,L/2-0.5*D/1.414-GL/1.414,L/2+0.5*D/1.414

K,31,L/2+GW/2,L/2-R1
K,32,L/2-GW/2,L/2-R1
K,33,L/2-GW/2,L/2-R2
K,34,L/2+GW/2,L/2-R2

*DIM,NUM_GAUGE,ARRAY,3,1
*DO,I,1,3,2
  L,10*I+1,10*I+2 $ L,10*I+2,10*I+3
  L,10*I+3,10*I+4 $ L,10*I+4,10*I+1
  L_CACHE=_RETURN

  AL,L_CACHE-3,L_CACHE-2,L_CACHE-1,L_CACHE
  A_CACHE=_RETURN

  ! 减去不必要的部分
  ASBA,A0,A_CACHE,,DELETE,KEEP
  ! 获取新生成面的序号
  *GET,A0,AREA,0,NUM,MAX
*ENDDO


LSEL,ALL
LSEL,R,LOC,X,L/2-R2,L/2+R2
LSEL,R,LOC,Y,L/2-R2,L/2+R2
LESIZE,ALL,,,ENUM_L

LSEL,INVE
LESIZE,ALL,,,ENUM_L


ASEL,ALL
ASEL,U,AREA,,A0
MSHKEY,1
AMESH,ALL

ASEL,INVE
MSHKEY,0
AMESH,ALL

ALLSEL,ALL

K,51,,,DEPTH-h
K,52,,,DEPTH
L,1,51
L_CACHE1=_RETURN
L,51,52
L_CACHE2=_RETURN
LESIZE,L_CACHE1,,,5
LESIZE,L_CACHE2,,,n

ASEL,ALL
VDRAG,ALL,,,,,,L_CACHE1,L_CACHE2

!! 选取单元
! 建立柱坐标系, 命名为11
K,100,L/2,L/2  ! 柱坐标系原点
K,101,L,L/2  ! 柱坐标系x轴方向
K,102,L/2,L  ! 柱坐标系"y"轴方向
CSKP,11,1,100,101,102
CSYS,11  ! 打开坐标系11

! 选取单元
ESEL,S,CENT,X,0,D0/2
ESEL,R,CENT,Z,DEPTH-H,DEPTH

!! 对单元进行排序
! 获取最大单元编号
*GET,EMAX,ELEM,,NUM,MAX
! 获取最小单元编号
*GET,EMIN,ELEM,,NUM,MIN
! 获取单元数
*GET,SUM_ELEM,ELEM,,COUNT
! 定义五个维数等于单元数的数组
*DIM,NE,,SUM_ELEM
*DIM,EX,,SUM_ELEM
*DIM,EY,,SUM_ELEM
*DIM,EZ,,SUM_ELEM
*DIM,EORDER,,SUM_ELEM

! 获取单元的编号以及坐标数据
II = 0  ! 辅助变量
*DO,I,EMIN,EMAX,1
  *IF,ESEL(I),EQ,1,THEN
    II = II+1  ! 如果单元被选中
    NE(II) = I  ! 则将其的序号记录在数组NE内
    ! 将其的坐标记录在数组内
    *GET,EX(II),ELEM,NE(II),CENT,X
    *GET,EY(II),ELEM,NE(II),CENT,Y
    *GET,EZ(II),ELEM,NE(II),CENT,Z
  *ENDIF
*ENDDO

!! 这里打算用matlab写一个排序程序
!! 把他封装为exe后在ANSYS里面调用
!! 不然排序太折磨人了
*CREATE,datawrite,mac  ! 创建写出宏
! 写出NE
*CFOPEN,NE,dat
  *VWRITE,NE(1)
  (960F6.0)
*CFCLOSE
! 写出EX
*CFOPEN,EX,dat
  *VWRITE,EX(1)
  (960F11.9)
*CFCLOSE
! 写出EY
*CFOPEN,EY,dat
  *VWRITE,EY(1)
  (960F12.6)
*CFCLOSE
! 写出EZ
*CFOPEN,EZ,dat
  *VWRITE,EZ(1)
  (960F6.3)
*CFCLOSE
*END  ! 宏创建完毕
Datawrite  ! 运行宏文件

!! 运行MATLAB排序文件
/sys,sorting.exe

!! 读入MATLAB排序结果
*CREATE,DATAREAD,mac
*VREAD,EORDER(1),EORDER,dat,,IJK
(f6.0)
*END
DATAREAD

!! 为数据提取做准备
! 激活整体坐标系
CSYS,0

! 提取第一组应变片对应的单元序号
! 选中第一组应变片对应的单元
ESEL,ALL
ESEL,R,CENT,X,L/2+R1,L/2+R2
ESEL,R,CENT,Y,L/2-GW/2,L/2+GW/2
ESEL,R,CENT,Z,DEPTH-DH,DEPTH+DH
! 获取区域内单元最大序号
*GET,NUM_GAUGE1_MAX,ELEM,0,NUM,MAX
! 获取区域内单元最小序号
*GET,NUM_GAUGE1_MIN,ELEM,0,NUM,MIN
! 获取区域内单元数量
*GET,COUNT_STRAIN_GAUGE1,ELEM,0,COUNT
! 定义一个用于储存单元序号的数组
*DIM,STRAIN_GAUGE1,,COUNT_STRAIN_GAUGE1
! 设定一个辅助参数
II=0
! 记录
*DO,I,NUM_GAUGE1_MIN,NUM_GAUGE1_MAX,1
  ! 判断单元是否被选中
  *IF,ESEL(I),EQ,1,THEN
    ! 如果单元被选中
    II=II+1
    ! 则将其记录在数组STRAIN_GAUGE1内
    STRAIN_GAUGE1(II)=I
  *ENDIF
*ENDDO  ! 结束记录

! 提取第三组应变片对应的单元序号
! 选中第三组应变片对应的单元
ESEL,ALL
ESEL,R,CENT,X,L/2-GW/2,L/2+GW/2
ESEL,R,CENT,Y,L/2-R2,L/2-R1
ESEL,R,CENT,Z,DEPTH-DH,DEPTH+DH
! 获取区域内单元最大序号
*GET,NUM_GAUGE3_MAX,ELEM,0,NUM,MAX
! 获取区域内单元最小序号
*GET,NUM_GAUGE3_MIN,ELEM,0,NUM,MIN
! 获取区域内单元数量
*GET,COUNT_STRAIN_GAUGE3,ELEM,0,COUNT
! 定义一个用于储存单元序号的数组
*DIM,STRAIN_GAUGE3,ARRAY,COUNT_STRAIN_GAUGE3
! 设定一个辅助参数
II=0
! 记录
*DO,I,NUM_GAUGE3_MIN,NUM_GAUGE3_MAX,1
  ! 判断单元是否被选中
  *IF,ESEL(I),EQ,1,THEN
    ! 如果单元被选中
    II=II+1
    ! 则将其记录在数组STRAIN_GAUGE2内
    STRAIN_GAUGE3(II)=I
  *ENDIF
*ENDDO  ! 结束记录

! 建立应变矩阵(ANSYS计算不了太复杂的式子)
*DIM,MATRIX_EP1,ARRAY,N,N
*DIM,MATRIX_EP3,ARRAY,N,N
! 建立两个算术用的变量
*SET,SUM_EP,0
*SET,AVG_EP,0


ALLSEL,ALL
FINISH

!!-----求解-----
/SOLU
ANTYPE,STATIC  ! 设置分析类型为STATIC
NLGEOM,ON  ! 打开大变形效应
NROPT,FULL  ! 使用不省略的NEWTON-RAPHSON选项

! 分步求解
*DO,I,1,1,1
! *DO,I,1,N,1
  /SOLU
  ! BIRTH OR DEATH
  *DO,J,1+(I-1)*(SUM_ELEM/N),I*(SUM_ELEM/N),1
    EKILL,EORDER(J)
  *ENDDO
  FINISH
  
  *DO,K,1,I,1
    /SOLU
    ! ! 设置载荷步
    ! *SET,TIME_STEP,100*I+K
    ! TIME,TIME_STEP

    ! 清除所有约束及载荷
    LSCLEAR,ALL

    !! 施加约束
    NSEL,ALL
    NSEL,R,LOC,Z,0-0.01,0+0.01
    NSEL,R,LOC,X,L/2-0.5,L/2+0.5
    NSEL,R,LOC,Y,L/2-0.5,L/2+0.5
    D,ALL,UZ
  
    !! 施加载荷
    ! 选中右侧待加载节点
    NSEL,ALL
    NSEL,R,LOC,X,L-0.01,L+0.01
    NSEL,R,LOC,Z,DEPTH-I*DH-0.01,DEPTH-(I-1)*DH+0.01
    ! 获取选中节点数量
    *GET,NUM_CACHE,NODE,0,COUNT
    ! 计算应分摊到每个节点上的数量
    *SET,DF,SIGMA_X*DA/NUM_CACHE
    ! 加载
    F,ALL,FX,DF
  
    ! 选中左侧待加载节点
    NSEL,ALL
    NSEL,S,LOC,X,0-0.01,0+0.01
    NSEL,R,LOC,Z,DEPTH-I*DH-0.01,DEPTH-(I-1)*DH+0.01
    ! 获取选中节点数量
    *GET,NUM_CACHE,NODE,0,COUNT
    ! 计算应分摊到每个节点上的数量
    *SET,DF,SIGMA_X*DA/NUM_CACHE
    ! 加载
    F,ALL,FX,-DF
  
    ALLSEL,ALL
    SOLVE
    FINISH

    !! 提取数据
    /POST1
    ETABLE,TABLE_EQV,EPTO,EQV

    *SET,DEP,0 $ *SET,SUM_EP,0
    *DO,II,1,COUNT_STRAIN_GAUGE1,1
      *GET,DEP,ELEM,STRAIN_GAUGE1(II),ETAB,TABLE_EQV
      *SET,SUM_EP,SUM_EP+DEP
    *ENDDO
    ! *SET,AVG_EP,SUM_EP/COUNT_STRAIN_GAUGE1
    ! *SET,MATRIX_EP1(I,K),AVG_EP
    *SET,MATRIX_EP1(I,K),SUM_EP

    *SET,DEP,0 $ *SET,SUM_EP,0
    *DO,II,1,COUNT_STRAIN_GAUGE3,1
      *GET,DEP,ELEM,STRAIN_GAUGE3(II),ETAB,TABLE_EQV
      *SET,SUM_EP,SUM_EP+DEP
    *ENDDO
    ! *SET,AVG_EP,SUM_EP/COUNT_STRAIN_GAUGE3
    ! *SET,MATRIX_EP3(I,K),AVG_EP
    *SET,MATRIX_EP3(I,K),SUM_EP
    FINISH
  *ENDDO
*ENDDO

!! 输出应变矩阵
*CREATE,MATRICES_OUTPUT,mac
*MWRITE,MATRIX_EP1,EP1,dat,,JIK,20,20
(20F25.22)
*MWRITE,MATRIX_EP3,EP3,dat,,JIK,20,20
(20F25.22)
*END
MATRICES_OUTPUT

!! 利用matlab进行计算
/sys,calculate.exe

!! 生死单元法
!-----TEST-----
! 选取单元
! CSYS,11
! ESEL,S,CENT,X,0,D0/2
! ESEL,R,CENT,Z,DEPTH-H,DEPTH
! EPLOT

! DEAD OR ALIVE
! *DO,I,1,SUM_ELEM,1
!   EKILL,EORDER(I)
!   ESEL,R,LIVE
!   EPLOT
! *ENDDO